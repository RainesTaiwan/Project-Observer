/**
 * Minecraft Bot - Node.js Mineflayer Controller
 * é€™æ˜¯èˆ‡ Minecraft éŠæˆ²ç›´æ¥äº¤äº’çš„ Node.js å±¤
 */

const mineflayer = require('mineflayer');
const { pathfinder, Movements, goals } = require('mineflayer-pathfinder');
const { Vec3 } = require('vec3');

// å¾ç’°å¢ƒè®Šé‡è®€å–é…ç½®
const MC_HOST = process.env.MC_HOST || 'mc-server';
const MC_PORT = parseInt(process.env.MC_PORT || '25565');
const BOT_USERNAME = process.env.BOT_USERNAME || 'Agent_001';

// å‰µå»º Bot
const bot = mineflayer.createBot({
  host: MC_HOST,
  port: MC_PORT,
  username: BOT_USERNAME,
  version: '1.20.1'
});

// åŠ è¼‰æ’ä»¶
bot.loadPlugin(pathfinder);

// Bot æº–å‚™å°±ç·’
bot.once('spawn', () => {
  console.log(`âœ… Bot ${BOT_USERNAME} spawned in the world`);
  
  // è¨­ç½®é»˜èªç§»å‹•è¡Œç‚º
  const mcData = require('minecraft-data')(bot.version);
  const defaultMove = new Movements(bot, mcData);
  bot.pathfinder.setMovements(defaultMove);
});

// éŒ¯èª¤è™•ç†
bot.on('error', (err) => {
  console.error('âŒ Bot error:', err);
});

bot.on('kicked', (reason) => {
  console.error('âŒ Bot was kicked:', reason);
});

bot.on('end', () => {
  console.log('ğŸ‘‹ Bot disconnected');
});

// ç›£è½èŠå¤©è¨Šæ¯
bot.on('chat', (username, message) => {
  if (username === bot.username) return;
  console.log(`ğŸ’¬ ${username}: ${message}`);
});

// è™•ç†ä¾†è‡ª Python çš„å‘½ä»¤
process.stdin.setEncoding('utf8');
process.stdin.on('data', async (data) => {
  try {
    const command = JSON.parse(data.trim());
    
    if (command.action === 'get_state') {
      // ç²å–ç•¶å‰ç‹€æ…‹
      const state = getCurrentState();
      process.stdout.write(JSON.stringify(state) + '\n');
      
    } else if (command.action === 'execute_code') {
      // åŸ·è¡Œå‹•æ…‹ä»£ç¢¼
      const result = await executeCode(command.code);
      process.stdout.write(JSON.stringify(result) + '\n');
    }
    
  } catch (err) {
    console.error('âŒ Error processing command:', err);
    process.stdout.write(JSON.stringify({
      success: false,
      error: err.message
    }) + '\n');
  }
});

/**
 * ç²å–ç•¶å‰éŠæˆ²ç‹€æ…‹
 */
function getCurrentState() {
  const position = bot.entity.position;
  
  // ç²å–é™„è¿‘å¯¦é«”
  const nearbyEntities = Object.values(bot.entities)
    .filter(entity => entity.position.distanceTo(position) < 32)
    .map(entity => ({
      type: entity.type,
      name: entity.name || entity.displayName,
      distance: entity.position.distanceTo(position).toFixed(2),
      position: entity.position
    }));
  
  // ç²å–é™„è¿‘æ–¹å¡Š
  const nearbyBlocks = [];
  for (let x = -16; x <= 16; x += 4) {
    for (let y = -8; y <= 8; y += 4) {
      for (let z = -16; z <= 16; z += 4) {
        const pos = position.offset(x, y, z);
        const block = bot.blockAt(pos);
        if (block && block.name !== 'air') {
          nearbyBlocks.push({
            name: block.name,
            position: { x: pos.x, y: pos.y, z: pos.z }
          });
        }
      }
    }
  }
  
  // ç²å–èƒŒåŒ…ç‰©å“
  const inventory = bot.inventory.items().map(item => ({
    name: item.name,
    count: item.count,
    slot: item.slot
  }));
  
  // ç²å–æ™‚é–“å’Œå¤©æ°£
  const timeOfDay = bot.time.timeOfDay < 6000 ? 'morning' :
                    bot.time.timeOfDay < 12000 ? 'day' :
                    bot.time.timeOfDay < 18000 ? 'evening' : 'night';
  
  const weather = bot.isRaining ? 'rain' : 'clear';
  
  return {
    position: { x: position.x, y: position.y, z: position.z },
    health: bot.health,
    food: bot.food,
    inventory: inventory,
    nearby_entities: nearbyEntities,
    nearby_blocks: nearbyBlocks,
    time_of_day: timeOfDay,
    weather: weather,
    biome: bot.blockAt(position)?.biome?.name || 'unknown'
  };
}

/**
 * åŸ·è¡Œå‹•æ…‹ç”Ÿæˆçš„ä»£ç¢¼
 */
async function executeCode(code) {
  try {
    // å‰µå»ºåŸ·è¡Œç’°å¢ƒ
    const context = {
      bot: bot,
      Vec3: Vec3,
      goals: goals,
      mcData: require('minecraft-data')(bot.version),
      
      // å¸¸ç”¨è¼”åŠ©å‡½æ•¸
      async moveToPosition(x, y, z) {
        const goal = new goals.GoalBlock(x, y, z);
        await bot.pathfinder.goto(goal);
      },
      
      async mineBlock(blockName) {
        const block = bot.findBlock({
          matching: (block) => block.name === blockName,
          maxDistance: 32
        });
        
        if (block) {
          await bot.dig(block);
          return { success: true, message: `Mined ${blockName}` };
        } else {
          return { success: false, error: `${blockName} not found` };
        }
      },
      
      async attackNearest(mobType) {
        const entity = bot.nearestEntity(e => 
          e.type === 'mob' && e.name === mobType && 
          e.position.distanceTo(bot.entity.position) < 16
        );
        
        if (entity) {
          await bot.attack(entity);
          return { success: true, message: `Attacked ${mobType}` };
        } else {
          return { success: false, error: `${mobType} not found` };
        }
      },
      
      async collectItem(itemName) {
        const item = bot.nearestEntity(e =>
          e.type === 'object' && e.name === itemName &&
          e.position.distanceTo(bot.entity.position) < 16
        );
        
        if (item) {
          await bot.pathfinder.goto(new goals.GoalNear(item.position.x, item.position.y, item.position.z, 1));
          return { success: true, message: `Collected ${itemName}` };
        } else {
          return { success: false, error: `${itemName} not found` };
        }
      }
    };
    
    // åŸ·è¡Œä»£ç¢¼
    const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
    const fn = new AsyncFunction(...Object.keys(context), code);
    const result = await fn(...Object.values(context));
    
    return {
      success: true,
      result: result,
      timestamp: new Date().toISOString()
    };
    
  } catch (err) {
    return {
      success: false,
      error: err.message,
      stack: err.stack,
      timestamp: new Date().toISOString()
    };
  }
}

console.log(`ğŸš€ Minecraft Bot Controller started`);
console.log(`ğŸ“¡ Connecting to ${MC_HOST}:${MC_PORT} as ${BOT_USERNAME}...`);
